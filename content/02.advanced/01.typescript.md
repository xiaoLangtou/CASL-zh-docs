---
title: TypeScript 支持
---



CASL 是用 [TypeScript] 编写的，这带来了几个好处：
* 更好的安全性，因为你可以控制可以使用哪些动作和主体
* 更好的 IDE 集成，因为你可以获得关于可以使用哪些类以及需要传递哪些参数的提示
* 更容易的库支持，我们可以忘记 `.d.ts` 和 `.js` 文件之间的同步问题

[TypeScript]: https://typescriptlang.org/

所以，让我们来玩一下它们

> 最低支持的 TypeScript 版本是 **3.8.3**。CASL 使用 [`export type` 语法](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export)

## 权限推断

`PureAbility` 类和 `createMongoAbility` 工厂函数接受 2 个**可选**泛型参数：

```ts
import { createMongoAbility, Subject, MongoQuery } from '@casl/ability';

type PossibleAbilities = [string, Subject];
type Conditions = MongoQuery;

const ability = createMongoAbility<PossibleAbilities, Conditions>();
```

> `Subject` 是一个特殊类型，表示 `PureAbility` 可以接受的所有可能主体。所以，它是 `object | string | Function | undefined`。

不要被复杂性吓到，`createMongoAbility` 默认使用这些类型，所以上面的例子与下面的例子相同：

```ts
import { createMongoAbility } from '@casl/ability';

const ability = new createMongoAbility();
```

这些类型足以保护你不传递错误的参数，但你可以进一步使它们更加严格。为了说明如何做到这一点，让我们考虑一个博客应用程序，它有 `User`、`Article` 和 `Comment` 实体，具有以下用户权限：

* 可以 `create`、`update`、`delete` 自己的 `Article` 或 `Comment`
* 可以 `read` 任何 `Article`、任何 `Comment` 和任何 `User`

所以，让我们通过将所有可能的动作和所有可能的主体指定为泛型参数来将其转换为 CASL：

```ts
import { createMongoAbility } from '@casl/ability';

type Actions = 'create' | 'read' | 'update' | 'delete';
type Subjects = 'Article' | 'Comment' | 'User';

const ability = createMongoAbility<[Actions, Subjects]>();
```

如果我们尝试在 [VSCode]（或其他支持 TypeScript 的 IDE）中输入 `ability.can(`，它会提供提示：

[VSCode]: https://code.visualstudio.com/


![CASL TypeScript action hints](https://casl.js.org/v6/images/casl-action-hints.png)


当你尝试指定第二个参数时也会发生同样的情况：


![CASL TypeScript subject hints](https://casl.js.org/v6/images/casl-subject-hints.png)


`AbilityBuilder` 和 `defineAbility` 函数也有相同的行为：

![CASL TypeScript AbilityBuilder hints](https://casl.js.org/v6/images/casl-abilitybuilder.png)


## 从接口和类推断主体类型

你也可以将接口指定为主体：

```ts
import { createMongoAbility } from '@casl/ability';

interface Article {
  id: number
  title: string
  content: string
  authorId: number
}

interface User {
  id: number
  name: string
}

interface Comment {
  id: number
  content: string
  authorId: number
}

type Action = 'create' | 'read' | 'update' | 'delete';
type Subject = Article | Comment | User | 'Article' | 'User' | 'Comment';

const ability = createMongoAbility<[Action, Subject]>();

ability.can('read', 'Article');
ability.can('write', 'Article'); // 错误，因为不存在的动作名称
ability.can('update', 'Coment') // 错误，因为拼写错误
```

以及类：

```ts
import { createMongoAbility } from '@casl/ability';

class Article {
  id: number
  title: string
  content: string
  authorId: number
}

type Action = 'create' | 'read' | 'update' | 'delete';
type Subject = typeof Article | Article;

const ability = createMongoAbility<[Action, Subject]>();

ability.can('read', Article);
ability.can('update', new Article());
```

指定所有可能的主体类型可能有点例行公事，特别是如果你有超过 3 个的话。为了使其更容易，CASL 提供了 `InferSubjects` TypeScript 辅助工具，它可以从[标记联合][tagged union]推断主体（此辅助工具检查 `kind` 和特殊的 `__caslSubjectType__` 属性以确定标记）

[tagged union]: https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions

> `__caslSubjectType__` 由 `subject` 辅助工具设置，要了解更多信息，请查看[主体类型检测](../../guide/subject-type-detection  )


![CASL TypeScript infer tagged union subject](https://casl.js.org/v6/images/casl-tagged-union-subject.png)


类也可以从 `InferSubjects` 推断：

![CASL TypeScript infer class subject](https://casl.js.org/v6/images/casl-class-subject.png)


甚至判别类（你需要将 `true` 传递给 `InferSubjects` 的第二个泛型参数）。

![CASL TypeScript infer discriminated class subject](https://casl.js.org/v6/images/casl-discriminated-class-subject.png)


同样的参数允许从类推断 `modelName` 静态属性（如果你想使用字符串而不是类来检查主体类型）

![CASL TypeScript infer class modelName](https://casl.js.org/v6/images/casl-class-subject-with-name.png)


此外，同样的行为也适用于补充包！所以，你将获得 React 的 `Can` 组件、Vue 的 `$can` 函数、Mongoose 的插件等的提示。

> 要了解更多信息，请阅读你选择的补充包的文档

但即使这还不是结束，你可以走得更远！

## 更安全的权限推断

对于大多数情况，上面建议的方法应该足够了，但如果你更喜欢确保极端的类型安全，你可以定义动作和主体之间的依赖关系。例如，用户只能读取应用程序中关于用户的信息，仅此而已，但可以管理文章：

```ts
import { createMongoAbility } from '@casl/ability';

type CRUD = 'create' | 'read' | 'update' | 'delete';
type Abilities = ['read', 'User'] | [CRUD, 'Article'];

const ability = createMongoAbility<Abilities>();

ability.can('read', 'User');
ability.can('create', 'User'); // 构建时错误！因为不允许创建用户
```

## 应用程序 Ability

乍一看，为了使用更安全的泛型参数，你的应用程序代码会变得更复杂，这是真的。但有一个逃生舱 - **伴生对象模式**：

```ts
import { MongoAbility, createMongoAbility, CreateAbility } from '@casl/ability';

type CRUD = 'create' | 'read' | 'update' | 'delete';
type Abilities = ['read', 'User'] | [CRUD, 'Article'];
export type AppAbility = MongoAbility<Abilities>;

export const createAppAbility = createMongoAbility as CreateAbility<AppAbility>;
// 或者你可以在需要时调用
const ability = createMongoAbility<AppAbility>();
```

这个简单的模式来自 Scala 的 TypeScript，它是一种将类型和对象配对在一起的方法。在 TypeScript 中，值和类型存在于单独的命名空间中，这允许对类型和类使用相同的名称。TypeScript 根据上下文理解使用哪一个。

## AbilityBuilder 类型推断

`AbilityBuilder` 构造函数接受单个参数，即我们要构建的 Ability 类型：

```ts
import { AbilityBuilder, PureAbility, createMongoAbility } from '@casl/ability';

// 我们可以传递自定义 Ability 类
const builder = new AbilityBuilder(PureAbility);

// 或者我们可以传递工厂函数
const builder = new AbilityBuilder(createMongoAbility);
```

> 从 v5 开始，`AbilityBuilder` 接受必需参数，即要构建的 `Ability` 类或能力工厂函数

多亏了这一点，`AbilityBuilder` 可以从 `Ability` 类型推断所有需要的类型。当我们定义 `AppAbility` 时，这特别有用，因为这样我们将获得 IDE 提示和类型安全：

* 指定的动作
* 指定的主体类型
* **条件中使用的属性**
* **指定的字段**

我们可以使用标记接口（支持 `kind`、`__typename` 和 `__caslSubjectType__` 标记字段）或类：

![CASL TypeScript AbilityBuilder conditions hints](https://casl.js.org/v6/images/casl-abilitybuilder-conditions-hints.png)

![CASL TypeScript AbilityBuilder fields hints](https://casl.js.org/v6/images/casl-abilitybuilder-fields-hints.png)


很酷的是，所有这些安全性都依赖于主体类型！尝试传递 `User` 主体类型来代替 `Post`，亲自看看！

### 使用点表示法的嵌套字段

如果我们需要基于嵌套字段定义条件，我们可以通过定义一个单独的接口来做到这一点：

```ts
import { MongoAbility, createMongoAbility } from '@casl/ability';

interface User {
  kind: 'User'
  id: number
  name: string
  address: {
    street: string
    building: string
  }
}

type AppAbility = MongoAbility<['read', User | 'User']>;

const { can } = new AbilityBuilder<AppAbility>(createMongoAbility);

type FlatUser = User & {
  'address.street': User['address']['street']
};

can<FlatUser>('read', 'Post', { 'address.street': 'test' });
// 它也适用于字段
can<FlatUser>('read', 'Post', ['address.street'], { 'address.street': 'test' })
```

## 有用的类型辅助工具

### RawRule

有时你可能需要手动创建 `RawRule`（或从数据库中获取它们）。在这种情况下，你需要显式地为它们指定类型。如果你有 `AppAbility` 的类型，请使用 `RawRuleOf<AppAbility>`，否则使用 `RawRuleFrom<Abilities, Conditions>`。

```ts
import { MongoAbility, RawRuleOf, RawRuleFrom, MongoQuery } from '@casl/ability';

type AppAbilities = ['read' | 'update', 'Article'];
type AppAbility = MongoAbility<AppAbilities>;

const rawRules: RawRuleOf<AppAbility>[] = [
  { action: 'read', subject: 'Article' }
];

// 或者
type AppRawRule = RawRuleFrom<AppAbilities, MongoQuery>;
async function getRulesFromDb(): Promise<AppRawRule[]> {
  // 实现
}
```

### RuleOf

与 `RawRule` 辅助工具类似，有一个用于 `Rule<Abilities, Conditions>` 的辅助工具 `RuleOf<AppAbility>`。你在应用程序层很不可能需要使用这些类型。

### AbilityOptionsOf

与 `RawRule` 类似，如果你不想显式使用 `AbilityOptions<Abilities, Conditions>`，你可以使用 `AbilityOptionsOf<AppAbility>`：

```ts
import { AbilityOptionsOf, MongoAbility, createMongoAbility } from '@casl/ability';

type AppAbilities = ['read' | 'update', 'Article'];
type AppAbility = MongoAbility<AppAbilities>;
const options: AbilityOptionsOf<AppAbility> = {
  detectSubjectType: (subject) => /* 自定义实现 */
};

const ability = createMongoAbility<AppAbilities>([], options);
```

### AnyAbility 和 AnyMongoAbility

这两种类型分别表示任何 `PureAbility` 实例和任何 `MongoAbility` 实例。它们通常很适合泛型类型中的限制。例如，这是 `AnyAbility` 在 `AbilityBuilder` 中的使用方式：

```ts
export class AbilityBuilder<T extends AnyAbility = AnyAbility> {
  // 实现细节
}
```

### MongoQuery

有两种类型表示内置的 mongo 操作符：

* `MongoQuery<T>` 是一个实际的 mongo 查询。\
  在由 `createMongoAbility` 工厂函数创建的 `PureAbility` 中用作条件限制。
* `MongoQueryOperators<T>` 表示支持的 MongoDB 操作符，它是 `MongoQueryFieldOperators<T>` 和 `MongoQueryTopLevelOperators<T>` 的联合，分别表示支持的字段和文档级操作符

### ForcedSubject

表示已使用 `subject` 辅助工具转换为特定主体的对象（即 POJO）。

> 有关详细信息，请参阅[主体类型检测](../../guide/subject-type-detection  #subject-helper)
