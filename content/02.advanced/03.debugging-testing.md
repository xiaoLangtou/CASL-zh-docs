---
title: 调试和测试

---

有时理解为什么应用中的某个操作对特定用户被禁止可能会有点复杂。在本指南中，你将学习常见的陷阱和调查根本原因的方法。让我们开始吧。

## 调试

`PureAbility` 的 `can` 和 `cannot` 方法返回布尔结果，不会解释原因或哪个规则禁止了该操作。要获取允许或禁止对主体执行操作的规则，你可以使用 `relevantRuleFor` 方法。它接受与 `can` 相同的参数：

```js
import { defineAbility } from '@casl/ability';

const ability = defineAbility((can) => {
  can('read', 'Article');
});

const rule = ability.relevantRuleFor('read', 'Article'); // 内部 `Rule` 类的实例
```

你可以使用 `rule.conditions` 或 `rule.fields` 字段来理解哪个规则导致了意外的结果。如果找不到规则，`relevantRuleFor` 返回 `null`，这种情况发生在你检查不存在的操作或主体的权限时：

```js
const rule = ability.relevantRuleFor('update', 'Article'); // null
```

当你使用带条件的直接规则和反向规则的组合时，这个方法特别有用：

```js @{data-filename="defineAbility.js"}
import { defineAbility, subject } from '@casl/ability';

export const article = subject.bind(null, 'Article');
export const user = { id: 1 };
export const ability = defineAbility((can, cannot) => {
  can('read', 'Article', { authorId: user.id });
  cannot('read', 'Article', { private: true })
});
```

> 为了简化，我将使用 `subject` 辅助函数而不是类来创建绑定类型的主体。你可以在[主体类型检测](../../guide/subject-type-detection  )中阅读更多其他方法。

现在让我们检查：

```js
import { user, ability, article } from './defineAbility';

const rule = ability.relevantRuleFor('read', article({ authorId: user.id }));
console.log(rule.conditions); // { authorId: 1 }

const forbiddenRule = ability.relevantRuleFor('read', article({ private: true }));
console.log(forbiddenRule.conditions); // { private: true }

const anotherRule = ability.relevantRuleFor('read', article({ authorId: 2 }));
console.log(anotherRule); // null，没有匹配的规则
```

理解为什么操作被禁止的另一种方法是使用[禁止原因](../../guide/intro#forbidden-reasons)功能。它允许为规则分配用户友好的解释

> 禁止原因不支持直接规则。查看 [#264](https://github.com/stalniy/casl/issues/264) 来跟踪此功能的状态

```js @{data-filename="defineAbilityWithReasons.js"}
import { defineAbility, subject } from '@casl/ability';

export const article = subject.bind(null, 'Article');
export const ability = defineAbility((can) => {
  can('read', 'Article');
  cannot('read', 'Article', { private: true }).because('Private content is protected by law');
});

const rule = ability.relevantRuleFor('read', 'Article'); // 内部 `Rule` 类的实例
```

我们可以使用相同的 `relevantRuleFor` 方法，但检查 `rule.reason` 字段：

```js
import { ability, article } from './defineAbilityWithReasons';

const rule = ability.relevantRuleFor('read', article({ private: true }));
console.log(rule.reason); // Private content is protected by law
```

## 测试

`PureAbility` 实例在函数式编程方面是纯的。这意味着对于相同的规则，它的 `can` 方法总是返回相同的结果。这就是为什么测试 CASL 权限没有太大收益，相反你应该测试规则分发逻辑。**这听起来是正确的，但只是乍一看**。让我们考虑一个例子：

```js @{data-filename="defineAbility.js"}
import { createMongoAbility, AbilityBuilder, subject } from '@casl/ability';

export const article = subject.bind(null, 'Article');

/**
 * 这个函数负责规则分发逻辑。
 * 我们需要测试它，而不是能力检查！
 */
export function defineRulesFor(user) {
  const { can, cannot, rules } = new AbilityBuilder(createMongoAbility);

  if (user.isAdmin) {
    can('manage', 'all');
  } else {
    can('read', 'Article');
    cannot('read', 'Article', { private: true });
  }

  return rules;
}

export const defineAbilityFor = user => createMongoAbility(defineRulesFor(user));
```

现在我们想确保管理员用户可以做任何事情，其他用户只能阅读非私有文章。使用 [mocha] + [chai] 或 [jest] 我们可以做到这一点（我们将使用 mocha 和 chai）：

```js
import { defineRulesFor } from './defineAbility';

describe('Permissions', () => {
  let user;

  describe('when user is an admin', () => {
    beforeEach(() => {
      user = { isAdmin: true };
    });

    it('can do anything', () => {
      expect(defineRulesFor(user)).to.deep.equal([
        { action: 'manage', subject: 'all' }
      ]);
    });
  });

  describe('when user is a regular user', () => {
    beforeEach(() => {
      user = { isRegular: true };
    });

    it('can read non private article', () => {
      expect(defineRulesFor(user)).to.deep.contain([
        { action: 'read', subject: 'Article' },
        { action: 'read', subject: 'Article', conditions: { private: true }, inverted: true }
      ]);
    });
  });
});
```

你看到问题了吗？**我们刚刚测试了实现细节，这是不好的！** 为什么？

规则逻辑非常具有表达性，你可以使用不同的规则组合来实现相同的结果。例如"用户可以阅读非私有文章"可以用另一种方式表达：

```js
import { AbilityBuilder, createMongoAbility } from '@casl/ability';

export function defineRulesFor(user) {
  const { can, cannot, rules } = new AbilityBuilder(createMongoAbility);

  if (user.isAdmin) {
    can('manage', 'all');
  } else {
    can('read', 'Article', { private: false });
  }

  return rules;
}
```

现在我们只有 1 个允许阅读非私有文章的直接规则！所以，我们有相同的权限，相同的支持案例集合，但我们的测试是**红色的**，这很糟糕。所以，如果我们测试规则分发逻辑，当我们因为某种原因决定更改规则时，很可能需要修复旧的测试。

权限逻辑非常重要，所以正确的测试方法是测试特定的案例。这可以节省你修复过度依赖实现细节的测试的时间，并确保下一版本的 CASL 不会破坏你的权限系统（如果确实破坏了，请[创建一个问题](https://github.com/stalniy/casl/issues/new)）。最终测试应该看起来像这样：

```js
import { defineAbilityFor, article } from './defineAbility';

describe('Permissions', () => {
  let user;
  let ability;

  describe('when user is an admin', () => {
    beforeEach(() => {
      user = { isAdmin: true };
      ability = defineAbilityFor(user);
    });

    it('can do anything', () => {
      expect(ability.can('manage', 'all')).to.be.true;
    });
  });

  describe('when user is a regular user', () => {
    beforeEach(() => {
      user = { isRegular: true };
      ability = defineAbilityFor(user);
    });

    it('can read non private article', () => {
      expect(ability.can('read', 'Article')).to.be.true;
      expect(ability.can('read', article({ title: 'test' }))).to.be.false; // 因为没有 private 字段
      expect(ability.can('read', article({ title: 'test', private: false }))).to.be.true;
      expect(ability.can('read', article({ private: true }))).to.be.false;
    });
  });
});
```

[mocha]: https://mochajs.org/
[chai]: http://chaijs.com/
[jest]: https://jestjs.io/
