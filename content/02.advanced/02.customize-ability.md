---
title: 自定义 Ability
categories: [advanced]
order: 65
meta:
  keywords: ~
  description: ~
---

CASL 在设计时考虑了可扩展性，这允许你使用自定义操作符扩展条件，提供自定义字段匹配器，甚至使用你自己的实现来匹配条件（例如，使用函数或 [json-schema]）！让我们看看如何做到这一点

[json-schema]: https://json-schema.org/

## 使用自定义操作符扩展条件

多亏了 [ucast](https://github.com/stalniy/ucast)，可以使用 MongoDB 查询语言在 CASL 中[定义条件](../../guide/conditions-in-depth)。通常这就足够了，但有时你可能想要限制可能的操作符，添加非标准操作符或 CASL 默认不包含的操作符之一（例如，[$nor]）。

让我们看一个如何添加 `$nor` 操作符的例子。为此，我们将使用 `@casl/ability` 包中的 `buildMongoQueryMatcher` 辅助函数。它允许添加或覆盖现有操作符：

[$nor]: https://docs.mongodb.com/manual/reference/operator/query/nor/

```ts
import {
  createMongoAbility,
  AbilityBuilder,
  Abilities,
  buildMongoQueryMatcher,
} from '@casl/ability';
import { $nor, nor } from '@ucast/mongo2js';

const conditionsMatcher = buildMongoQueryMatcher({ $nor }, { nor });

export default function defineAbilityFor(user: any) {
  const { can, build } = new AbilityBuilder(createMongoAbility);

  can('read', 'Article', {
    $nor: [{ private: true }, { authorId: user.id }]
  });

  return build({ conditionsMatcher });
}
```

> 为了简化，我们使用 `user: any`，在实际应用中你应该避免这样做

`buildMongoQueryMatcher` 扩展现有的操作符集合，所以如果你想限制可用的操作符，你不应该使用它。例如，让我们只允许使用 `$eq` 和 `$in` 操作符：

```ts
import {
  createMongoAbility,
  MongoAbility,
  AbilityBuilder,
  Abilities,
  MongoQueryFieldOperators,
  ConditionsMatcher,
} from '@casl/ability';
import { $in, within, $eq, eq, createFactory, BuildMongoQuery } from '@ucast/mongo2js';

type RestrictedMongoQuery<T> = BuildMongoQuery<T, Pick<MongoQueryFieldOperators, '$eq' | '$in'>>;
const conditionsMatcher: ConditionsMatcher<RestrictedMongoQuery> = createFactory({ $in, $eq }, { in: within, eq });
type AppAbility = MongoAbility<Abilities, RestrictedMongoQuery>;

export default function defineAbilityFor(user: any) {
  const { can, build } = new AbilityBuilder(createMongoAbility);

  can('read', 'Article', { authorId: user.id } });
  can('read', 'Article', { status: { $in: ['draft', 'published'] } });

  return build({ conditionsMatcher });
}
```

> 阅读 [@ucast/mongo2js 文档](https://github.com/stalniy/ucast/tree/master/packages/mongo2js#custom-operator) 页面了解如何创建自定义操作符。

通过限制操作符，你不仅禁止其他开发者使用更复杂的条件，还可以使你的前端包大小更小（感谢支持 tree-shaking 的打包工具）。

## 自定义条件匹配器实现

如果你想实现自定义条件匹配器，你应该使用 `PureAbility` 类而不是 `createMongoAbility` 工厂函数。`createMongoAbility` 是一个工厂函数，它创建具有 `conditionsMatcher` 和 `fieldMatcher` 选项默认值的 `PureAbility` 实例（即 mongo 条件匹配器和字段模式匹配器）。

> "Pure" 前缀与函数式编程无关。它只是意味着这个类没有预定义的配置。

条件匹配器是一个工厂函数，它接受 `rule.conditions` 并返回一个接受对象并返回布尔值的函数。所有这些对条件匹配器的限制都由 `ConditionsMatcher` 泛型类型强制执行，你可以从 `@casl/ability` 导入它。

让我们实现允许使用函数作为条件匹配器的匹配器：

```ts
import {
  PureAbility,
  AbilityBuilder,
  AbilityTuple,
  MatchConditions,
} from '@casl/ability';

type AppAbility = PureAbility<AbilityTuple, MatchConditions>;
const lambdaMatcher = (matchConditions: MatchConditions) => matchConditions;

export default function defineAbilityFor(user: any): AppAbility {
  const { can, build } = new AbilityBuilder<AppAbility>(PureAbility);

  can('read', 'Article', ({ authorId }) => authorId === user.id);
  can('read', 'Article', ({ status }) => ['draft', 'published'].includes(status));

  return build({ conditionsMatcher: lambdaMatcher });
}
```

> 条件匹配器只能是同步的！

如果你需要序列化规则或将它们转换为数据库查询，我们不建议使用函数进行匹配逻辑。默认匹配器应该涵盖大多数情况。

## 自定义字段匹配器

字段匹配器是一个接受字段模式并返回一个接受字段名称并返回布尔值的函数的函数。默认情况下，CASL 使用支持 `user.address.*` 或 `user.*.name` 等模式的字段模式匹配器。但你可以实现自己的：

```ts
import { PureAbility, AbilityBuilder, AbilityTuple } from '@casl/ability';

type AppAbility = PureAbility<AbilityTuple>;
const fieldMatcher = (fields: string[]) => (field: string) => fields.includes(field);

export default function defineAbilityFor(user: any): AppAbility {
  const { can, build } = new AbilityBuilder<AppAbility>(PureAbility);

  can('read', 'Article', ['title', 'description']);

  return build({ fieldMatcher });
}
```

这个简单的 `fieldMatcher` 不支持字段模式，所以你只能指定确切的字段名称。
