---
title: 能力转数据库查询
categories: [advanced]
order: 75
meta:
  keywords: ~
  description: ~
---

有时你需要根据用户在应用中能够执行的操作来限制从数据库返回的记录。`@casl/ability/extra` 提供了 `rulesToQuery` 辅助函数，它帮助将规则转换为特定数据库的查询。这个函数接受 4 个参数：

1. `PureAbility` 的实例
2. 你想要获取规则的 `action`
3. 你计划查询的 `subjectType`
4. 转换函数，它将规则作为唯一参数并返回数据库查询块

该辅助函数将所有查询块聚合到一个具有 `$or` 和 `$and` 属性的单个对象中。直接规则的查询块收集在 `$or` 数组中，反向规则收集在 `$and` 数组中。**如果提供的能力不允许对提供的主体类型执行提供的操作，此函数返回 `null`**。

> 查看 [@casl/mongoose](../../package/casl-mongoose) 获取与 [MongoDB](https://www.mongodb.com/) 集成的详细信息

为了更好地理解逻辑，让我们为 [sequelize](https://sequelize.org/) 实现**一个基本的辅助函数**。

```js @{data-filename="toSequelizeQuery.js"}
const { rulesToQuery } = require('@casl/ability/extra');
const { Op } = require('sequelize');

/**
 * 递归遍历深度嵌套对象的巧妙方法。
 * 参见 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Parameters
 */
function symbolize(query) {
  return JSON.parse(JSON.stringify(query), function keyToSymbol(key, value) {
    if (key[0] === '$') {
      const symbol = Op[key.slice(1)];
      this[symbol] = value;
      return;
    }

    return value;
  });
}

function ruleToSequelize(rule) {
  return rule.inverted ? { $not: rule.conditions } : rule.conditions;
}

function toSequelizeQuery(ability, subject, action) {
  const query = rulesToQuery(ability, action, subject, ruleToSequelize);
  return query === null ? query : symbolize(query);
}

async function accessibleBy(ability, action = 'read') {
  const query = toSequelizeQuery(ability, action, this.name);

  if (query === null) { // 没有可访问的记录，所以不需要向数据库发送查询
    return [];
  }

  return this.findAll({
    where: query;
  });
}

module.exports = {
  toSequelizeQuery,
  accessibleBy,
};
```

在这个例子中，我们使用 `rulesToQuery` 来遍历规则并聚合 sequelize 查询。`$not` 操作符用于反转反向规则条件的结果。从 sequelize v6 开始，操作符别名被移除了（[sequelize#10820](https://github.com/sequelize/sequelize/issues/10820)），所以我们需要将基于字符串的键转换为符号。为此，我们使用了一个技巧，即使用自定义的 `reviver` 参数对 JSON 对象进行字符串化和解析，它检测以 `$` 开头的键并将它们替换为相应的符号。

然后，我们可以使用这个函数在你的模型中定义静态方法或作用域。在这里，我们将定义静态方法，因为它的使用看起来比自定义作用域更自然和可读：

```js @{data-filename="Article.js"}
const { Model, DataTypes } = require('sequelize');
const { accessibleBy } = require('./toSequelizeQuery');

module.exports = (sequelize) => {
  class Article extends Model {
    static accessibleBy = accessibleBy;
  }

  Article.init({
    title: {
      type: DataTypes.STRING,
      allowNull: false
    },
    published: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: false
    }
    // 其他列的定义
  }, {
    sequelize,
    modelName: Article.name,
  });

  return Article;
}
```

现在我们可以使用我们的静态方法获取可访问的记录：

```js
const { Sequelize } = require('sequelize');
const { defineAbility } = require('@casl/ability');
const defineArticle = require('./Article');

const sequelize = new Sequelize('sqlite::memory');
const Article = defineArticle(sequelize);

async function main() {
  const ability = defineAbility(can => can('read', Article, { published: true }));
  const articles = await Article.accessibleBy(ability);

  console.log(articles);
}

main().catch(console.error);
```

这个实现是基础的，因为它不支持连接查询。查看 [#8](https://github.com/stalniy/casl/issues/8) 来跟踪 CASL 中 SQL 支持的状态。
