---
title: 更清晰的 can API
categories: [cookbook]
order: 15
meta:
  keywords: ~
  description: ~
---

## 问题

CASL 使用 `can` 和 `cannot` 函数名来定义和检查权限。对于你们中的一些人来说，这可能看起来令人困惑，你们希望更明确，而不依赖于执行上下文。

示例：

```ts
import { defineAbility } from '@casl/ability';

// 定义能力
const ability = defineAbility((can, cannot) => {
  can('read', 'Post');
  cannot('read', 'Post', { private: true });
});

// 检查能力
ability.can('read', 'Post');
```

**主要缺点**是你需要记住上下文以及[定义能力的 `can`](/guide/intro) 和检查能力的 `can` 之间函数签名的差异。

## 解决方案

我们可以做的是使用不同的变量名，所以上面的示例看起来是这样的：

```ts
import { defineAbility } from '@casl/ability';

// 定义能力
const ability = defineAbility((allow, forbid) => {
  allow('read', 'Post');
  forbid('read', 'Post', { private: true });
});

// 检查能力
ability.can('read', 'Post');
```

使用纯 `AbilityBuilder` 的相同示例可以使用[对象解构]以类似的方式编写：

```ts
import { AbilityBuilder, createMongoAbility } from '@casl/ability';

// 定义能力
const { can: allow, cannot: forbid, build } = new AbilityBuilder(createMongoAbility);

allow('read', 'Post');
forbid('read', 'Post', { private: true });

const ability = build();

// 检查能力
ability.can('read', 'Post');
```

**主要优势**是每个人都清楚地看到 `allow` 和 `can` 是不同的方法，并且可能有不同的签名（因为它们确实不同！）。

> 查看[定义规则](../../guide/define-rules)了解定义能力的其他方法。

## 何时避免

这种方法确实让初级开发者和那些更喜欢显式代码而不是约定或上下文的人更容易使用 CASL。如果上下文代码不困扰你，你可以避免这种方法。

[对象解构]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Assigning_to_new_variable_names
