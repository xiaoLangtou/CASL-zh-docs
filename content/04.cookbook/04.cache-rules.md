---
title: 缓存能力
categories: [cookbook]
order: 20
meta:
  keywords: ~
  description: ~
---

> 这个配方针对后端开发者。我们在本指南中使用 [express](https://expressjs.com/) 库，因此需要了解它（或类似框架）的知识。

## 问题

构造 `PureAbility` 实例需要大量时间或需要额外的数据库往返。

让我们考虑一个例子，用户可以管理自己的设备，但**设备没有**对所有者的引用。在这种情况下，我们需要获取所有设备 ID 以创建 `MongoAbility` 实例：

```ts @{data-filename="defineAbility.ts"}
import { AbilityBuilder, createMongoAbility, MongoAbility } from '@casl/ability';
import { getDevicesOf } from '../services/device';

export type AppAbility = MongoAbility;

export async function defineRulesFor(user) {
  const { can, rules } = new AbilityBuilder<AppAbility>(createMongoAbility);

  const devices = await getDevicesOf(user);
  const ids = devices.map(device => device.id);

  can('read', 'Device', { id: { $in: ids } });
  // 其他规则

  return rules;
}

export async function defineAbilityFor(user) {
  const rules = await defineRulesFor(user);
  return new AppAbility(rules);
}
```

> 底层数据库对本指南并不重要。相同的原则适用于任何其他数据库系统。

## 解决方案

为了加快速度，你可以缓存能力实例的创建。

## 演示

有几种方法可以做到这一点：

> 确保你将所有异步 express 中间件包装在 try/catch 中，因为 express 4.x 不支持 `Promise` 拒绝。为了简单起见，我们在下面的示例中不这样做。

### 内存 LRU 缓存

[LRU 缓存](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_Recently_Used_.28LRU.29) 是一种丢弃最近最少使用条目的缓存类型，因此允许为最活跃的用户存储能力，即那些在你的系统上产生最高负载的用户。

> 有一个相当流行的 [lru-cache](https://www.npmjs.com/package/lru-cache) Node.js 包，我们将在本指南中使用它，但你可以以相同的方式使用任何其他实现。

所以，让我们创建一个为 `Request` 对象定义能力的中间件：

```ts @{data-filename="provideAbility.ts"}
import LruCache from 'lru-cache';
import { defineAbilityFor } from './defineAbility';

// 存储 1000 个最活跃用户的能力
export const ABILITIES_CACHE = new LruCache(1000);

export async function provideAbility(req, res, next) {
  if (ABILITIES_CACHE.has(req.user.id)) {
    req.ability = ABILITIES_CACHE.get(req.user.id);
  } else {
    req.ability = await defineAbilityFor(req.user);
    ABILITIES_CACHE.set(req.user.id, req.ability);
  }

  next();
}
```

现在我们可以使用这个中间件为特定用户提供能力并检查其权限：

```ts @{data-filename="boot.ts"}
import { provideAbility } from './provideAbility';
import express from 'express';

const app = express();

// 应用配置和其他中间件

app.use(provideAbility);

app.listen(3000, () => console.log('app is listening on http://localhost:3000'));
```

> 不要忘记在用户添加或删除设备时使缓存失效

### 在会话存储中

如果应用程序使用存储的会话，并且 [LRU 缓存](#内存-lru-缓存) 不能满足你的需求，你可以将能力存储在用户的会话中（例如，Redis、Memcached）。为什么我们存储规则而不是 `PureAbility` 实例？因为会话存储在存储对象之前会序列化对象。规则很容易序列化，而 `PureAbility` 实例不是，但可以从规则创建。

Express 中的会话通常通过 [express-session](https://www.npmjs.com/package/express-session) 和 [connect-redis](https://www.npmjs.com/package/connect-redis) 的帮助来实现。我们将以相同的方式进行。

所以，剩下的唯一事情就是实现 `provideAbility` 中间件，它将特定用户的规则保存在他的会话存储中。注意我们使用 `defineRulesFor` 而不是 `defineAbilityFor` 函数：

```ts @{data-filename="provideAbility.ts"}
import { createMongoAbility } from '@casl/ability';
import { defineRulesFor } from './defineAbility';

export async function provideAbility(req, res, next) {
  let rules = req.session.abilityRules;

  if (!req.session.abilityRules) {
    rules = await defineRulesFor(req.user);
    req.session.abilityRules = rules
  }

  req.ability = createMongoAbility(rules);
  next();
}
```

并确保你在 `app.ts` 文件中正确配置 express-session。它应该是这样的：

```ts @{data-filename="app.ts"}
import { provideAbility } from './provideAbility';
import express from 'express';
import session from 'express-session';
import redis from 'redis';
import createRedisStore from 'connect-redis';

const app = express();
const RedisStore = createRedisStore(session);

app.use(session({
  store: new RedisStore({ client: redis.createClient() }),
  secret: 'my app session secret',
}));

// 应用配置和其他中间件

app.use(provideAbility);
```

### 在 JWT 令牌载荷中

如果应用程序使用无状态 [JWT](https://en.wikipedia.org/wiki/JSON_Web_Token) 令牌，你可以将规则嵌入到其载荷中：

```ts @{data-filename="login.ts"}
import jwt from 'jsonwebtoken';
import { defineRulesFor } from './defineAbility';

export async function login(req, res) {
  const token = jwt.sign({
    id: req.user.id,
    rules: await defineRulesFor(req.user)
  }, 'secret', { expiresIn: '1d' })

  res.send({ token })
}
```

并实现 `provideAbility` 中间件，它从客户端在 `Authorization` 头中提供的 jwt 令牌创建能力：

```ts @{data-filename="provideAbility.ts"}
import { createMongoAbility } from '@casl/ability';
import jwt from 'jsonwebtoken';
import { defineRulesFor } from './defineAbility';

export async function provideAbility(req, res, next) {
  try {
    const token = req.headers.authorization;
    const { rules } = jwt.verify(token, req.app.get('jwtSecret'));

    req.ability = createMongoAbility(rules);
    next();
  } catch (error) {
    next(error);
  }
}
```

> 你可以使用 `packRules` 和 `unpackRules` 将规则载荷大小减少 2 倍。查看 [@casl/ability/extra 的 API 文档](/api/casl-ability-extra#pack-rules) 了解详情

## 何时避免

在以下几种情况下你应该避免缓存：

1. 能力数量很少。
2. 对数据库的请求在服务层被缓存。
3. 你的权限是动态的，这使得很难保持缓存与数据存储状态同步。
4. 你可以重新思考领域模型以简化权限逻辑（反规范化一些实体或添加额外的外键）。

## 替代方案

另一种方法是重新思考领域（或数据）模型，这样你就可以从每个请求加载的信息中构建能力（例如，完全基于 `user` 的详细信息）。在[问题](#问题)中描述的情况下，我们可以向 `Device` 模型添加 `userId` 字段，这将使事情在没有额外缓存的情况下快速工作。
