---
title: 基于声明的授权
categories: [cookbook]
order: 16
meta:
  keywords: ~
  description: ~
---

## 问题

你需要实现基于声明（或操作）的简单授权（即权限管理）逻辑。换句话说，你有操作（或声明），但没有可以应用此操作的"主体"概念（或者在你的应用中这不重要）。这个概念与[基于声明的身份](https://en.wikipedia.org/wiki/Claims-based_identity)非常相似。

实现这一点的最简单方法是创建一个包含所有可能操作（或声明）的数组，并检查用户对象上是否存在声明：

```ts
const ACTIONS = ['review', 'publish', 'read'];

function publishArticle(article, user) {
  if (!user.permissions.includes('publish')) {
    throw new Error('You cannot publish articles');
  }

  // 发布文章的逻辑
}
```

手工解决方案的**缺点**是什么：

1. 你需要测试。\
   知道你的权限逻辑是可靠的非常重要，否则就没有意义。
2. 你需要维护它（即修复错误）。\
   如果你发现了一个错误，你需要修复它并添加测试。但是如果错误是被攻击者发现的，你会怎么做？
3. 你需要发展它。\
   世界在不断变化，你的业务需求也在不断变化。如果你需要添加更复杂的权限逻辑（例如，每个主体或每个属性的权限），你将需要自己实现和测试它。

所有这些都消耗时间和资源，结果推迟了你产品的交付。

## 解决方案

幸运的是，CASL 支持基于声明的授权。上面的示例可以在 CASL 中表示为：

```ts
import { defineAbility, PureAbility } from '@casl/ability';

type AppAbility = PureAbility<Actions>;
type Actions = 'review' | 'publish' | 'read';

const ability = defineAbility<AppAbility>((can) => {
  can('review');
  can('publish');
  can('read');
});

function publishArticle(article: object, ability: AppAbility) {
  if (ability.cannot('publish')) {
    throw new Error('You cannot publish articles');
  }

  // 发布文章的逻辑
}
```

这样做的**优势**：

1. 你可以从简单的权限逻辑开始，并与你的业务需求一起发展。
2. 由于 [rollup] 和 [webpack] 中的 tree-shaking，CASL 对于基于声明的授权只需要 1.5KB。
3. 无需维护自己的解决方案。很多人使用并为像 CASL 这样的开源库创建问题，所以你可以免费获得支持、错误修复和新功能。

[rollup]: https://rollupjs.org/guide/en/
[webpack]: https://webpack.js.org/

## 何时避免

有时应用程序使用合并的操作和主体作为声明：`create_article`、`read_article`、`read_user`。在这种情况下，最好分离操作和主体。这将允许你稍后向你的能力添加条件和字段，而无需重构整个应用程序。
