---
title: 主体类型检测
categories: [guide]
order: 50
meta:
  keywords: ~
  description: ~
---

让我们考虑一个例子：

```js @{data-filename="defineAbility.js"}
import { defineAbility } from '@casl/ability';

export default defineAbility((can) => {
  can('read', 'Article');
});
```

我们允许每个人读取文章，现在让我们测试一下：

```js
import ability from './defineAbility';

const article = {};
ability.can('read', article);
```

你认为最后一行返回什么？它返回 `false`，但为什么？因为 `article` 变量不是 `Article` 类型。现在你应该有一个问题：

## CASL 如何检测主体类型？

首先要澄清的是"什么是主体类型？"。主体类型基本上是对象的类型，在面向对象编程中，类表示实例元数据并表示对象元数据信息。

> 从 v5 开始，CASL 将字符串、函数和类视为主体类型。任何其他类型都被视为主体，CASL 需要为其检测主体类型。

当我们在 `ability.can` 中传递一个对象作为第二个参数时，CASL 获取 `object.constructor.modelName` 作为主体类型，如果没有指定 `modelName`，则回退到 `object.constructor.name`。

在上面的例子中，`article` 变量包含一个普通对象，它的构造函数没有 `modelName`，所以 CASL 获取其 `constructor.name` 作为主体类型。最终，我们得到 `Object`。没有针对 `Object` 主体类型的规则，这就是为什么当我们试图检查是否可以读取该对象时得到 `false`。那么，我们如何修复这个例子？最简单的方法是为我们的 `Article` 模型使用一个特殊的类：

```js
import ability from './defineAbility';

class Article {}

const article = new Article();
ability.can('read', article); // true
```

[terser]: https://terser.org/
[uglifyjs]: http://lisperator.net/uglifyjs/

**上面的例子在生产环境中不会工作**，如果我们使用压缩。为了修复它，我们需要在 `Article` 类上设置一个静态属性：

```js
import ability from './defineAbility';

class Article {
  static get modelName() {
    return 'Article'
  }
}

const article = new Article();
ability.can('read', article); // true
```

这对于后端来说是可以的，因为类自然地用于描述和封装领域逻辑，但对于前端来说不是。通常前端处理 [DTO] 对象（即普通的 js 对象）。

[DTO]: https://en.wikipedia.org/wiki/Data_transfer_object

CASL 提供 2 个选项来处理 DTO 对象：

1. 使用 `subject` 辅助函数。
2. 使用自定义主体类型检测算法。

## subject 辅助函数

CASL 提供内置的 `subject` 辅助函数，它为提供的对象设置主体类型。所以，上面的例子我们可以重写为：

```js
import { subject } from '@casl/ability';
import ability from './defineAbility';

const article = {};
ability.can('read', subject('Article', article)); // true
```

它在提供的 DTO 上定义只读、不可配置和不可枚举的 `__caslSubjectType__` 属性，因此可以在主体类型检测算法中使用。

> 如果你尝试对之前由辅助函数处理过的对象使用不同主体类型的 `subject` 辅助函数，CASL 将抛出异常

所以，现在你有 2 个选项：

1. 在使用 `ability.can` 的任何地方都使用 `subject` 辅助函数，如上面的例子所示。
2. 从服务器检索所有 [DTO] 后为它们设置主体类型

所以，让我们看看第二个选项的含义：

```js
import { subject } from '@casl/ability';

export async function getArticles() {
  const response = await fetch('/api/articles');
  const body = await response.json();

  return body.articles.map(article => subject('Article', article));
}
```

> 第二种方法有点取巧，因为它混合了职责。现在，你的服务与 CASL 耦合。这对于短期或中小型应用程序来说是可以的，但对于大型应用程序应该避免

现在我们可以安全地使用 `ability.can` 检查文章的权限，而不用担心主体的类型，因为它之前已经定义过了。

为了使代码更具可读性，你可以根据上下文将 `subject` 别名为 `a` 或 `an`，所以上面的例子可能看起来像这样：

```js
import { subject as an } from '@casl/ability';

export async function getArticles() {
  const response = await fetch('/api/articles');
  const body = await response.json();

  return body.articles.map(object => an('Article', object)); // read as "an Article object"
}
```

## 自定义主体类型检测

有时你需要定义自己的类型检测算法（例如，[GraphQL] 提供元数据字段 `__typename`，它返回对象的类型）

[GraphQL]: https://graphql.org/

对于这种情况，我们可以通过提供 `detectSubjectType` 选项来覆盖内置算法：

```js
import { AbilityBuilder, createMongoAbility } from '@casl/ability';

const { can, build } = new AbilityBuilder(createMongoAbility);

can('read', 'Article');

const ability = build({
  detectSubjectType: object => object.__typename
});

const article = { __typename: 'Article' };
ability.can('read', article); // true
```

自定义检测函数必须返回一个主体类型（字符串、类或函数）。

使用 `defineAbility` 函数也可以实现同样的效果：

```js
import { defineAbility } from '@casl/ability';

const ability = defineAbility((can) => {
  can('read', 'Article');
}, {
  detectSubjectType: object => object.__typename
});

const article = { __typename: 'Article' };
ability.can('read', article); // true
```

重要的是要注意 `detectSubjectType` 负责将对象映射到其对应的类型。当我们在 `ability.can` 中传递类、函数或字符串时，它们会自动被视为主体类型，不会为它们调用 `detectSubjectType`。

### 使用类作为主体类型

如我们之前所说，在后端使用类来建模领域逻辑是很常见的。所以，你们中的一些人可能想在权限定义中使用类作为主体类型。为此，我们需要一个自定义的 `detectSubjectType` 函数：

```js
import { defineAbility } from '@casl/ability';

class Article {}

const ability = defineAbility((can) => {
  can('read', Article);
}, {
  detectSubjectType: object => object.constructor
});

ability.can('read', new Article()); // true
ability.can('read', Article); // true
```

或者使用 `AbilityBuilder`：

```js
import { AbilityBuilder, createMongoAbility } from '@casl/ability';

class Article {}

const { can, build } = new AbilityBuilder(createMongoAbility);

can('read', Article);

const ability = build({
  detectSubjectType: object => object.constructor
});

ability.can('read', new Article()); // true
ability.can('read', Article); // true
```

如果你想在 TypeScript 中使用类，你需要转换 `object.constructor`（详情请阅读 [这个 TypeScript 问题](https://github.com/microsoft/TypeScript/issues/3841)）：

```ts
import { AbilityBuilder, createMongoAbility, MongoAbility, ExtractSubjectType } from '@casl/ability';

class Article {}

type Actions = 'read' | 'update';
type Subjects = Article | typeof Article;
type AppAbility = MongoAbility<[Actions, Subjects]>;

const { can, build } = new AbilityBuilder<AppAbility>(createMongoAbility);

can('read', Article);

const ability = build({
  // if you don't use permission specific types, you can cast return value to `SubjectType` type
  detectSubjectType: object => object.constructor as ExtractSubjectType<Subjects>
});

ability.can('read', new Article()); // true
ability.can('read', Article); // true
```
