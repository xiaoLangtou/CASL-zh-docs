---
title: 定义规则
categories: [guide]
order: 20
meta:
  keywords: ~
  description: ~
---

有 3 种方式可以定义能力：
* 使用 `defineAbility` 函数
* 使用 `AbilityBuilder` 类
* 使用 `JSON` 对象

为了了解使用哪种方式，让我们更多地了解每一种。

## defineAbility 函数

此函数是一个 [DSL]，允许使用 `can` 和 `cannot` 方法创建 `MongoAbility` 实例。它允许定义和使用 `MongoAbility` 实例而无需编写太多代码。

[DSL]: https://en.wikipedia.org/wiki/Domain-specific_language

### defineAbility 示例

```js
import { defineAbility } from '@casl/ability';

export default defineAbility((can, cannot) => {
  can('read', 'Post');
  cannot('delete', 'Post', { published: true });
});
```

您可以在单个 `can`（或 `cannot`）函数中传递多个操作、主体和字段。所以，不用

```js
import { defineAbility } from '@casl/ability';

export default defineAbility((can, cannot) => {
  can('read', 'Post');
  can('update', 'Post');
  can('read', 'Comment');
  can('update', 'Comment');
});
```

您可以这样做：

```js
import { defineAbility } from '@casl/ability';

export default defineAbility((can, cannot) => {
  can(['read', 'update'], ['Post', 'Comment']);
});
```

> 要了解更多关于 `can` 和 `cannot` 函数参数的信息，请阅读 [AbilityBuilder API](/api/casl-ability#abilitybuilder)

### 何时使用 defineAbility

* 单元测试
* 示例和学习资源
* 原型或非常简单的应用程序

因此，为了保持示例简单明了，我们将在本文档的大部分代码片段中使用 `defineAbility`。

### 为什么不推荐 defineAbility

这个函数没有什么极其错误的地方，但在您的应用程序中使用它时有几个缺点：

1. 在大多数情况下，规则依赖于用户请求，因此使用回调样式定义权限会增加额外的嵌套并增加认知复杂性。
2. 它只能创建与 [MongoDB 条件](../guide/conditions-in-depth) 一起工作的 `MongoAbility` 实例，因此您将无法使用另一种语言来匹配条件。

> 请参见[自定义能力](../../advanced/customize-ability)以了解更多关于不同能力类和自定义可能性的信息。

## AbilityBuilder 类

此类实现了 `can` 和 `cannot` 函数，使得可以使用 [DSL] 语法编写规则。**这是使用 DSL 语法定义规则的推荐方式**

### AbilityBuilder 示例

使用 `AbilityBuilder` 类编写的 [defineAbility 示例](#defineability-示例) 看起来稍微冗长一些：

```js
import { AbilityBuilder, createMongoAbility } from '@casl/ability'

const { can, cannot, build } = new AbilityBuilder(createMongoAbility);

can('read', 'Post');
cannot('delete', 'Post', { published: true });

export default build();
```

但它允许定义规则而无需额外的嵌套，这在您基于条件逻辑构建规则时尤其重要：

```js
import { AbilityBuilder, createMongoAbility } from '@casl/ability'

export default function defineAbilityFor(user) {
  const { can, cannot, build } = new AbilityBuilder(createMongoAbility);

  if (user.isAdmin) {
    can('manage', 'all'); // read-write access to everything
  } else {
    can('read', 'all') // read-only access to everything
  }

  cannot('delete', 'Post', { published: true });

  return build();
}
```

> 要了解更多关于 `can` 和 `cannot` 函数参数的信息，请阅读 [AbilityBuilder API](/api/casl-ability#abilitybuilder)

对于更高级的情况，可以使用 `AbilityBuilder` 的 `rules` 属性并手动创建 `MongoAbility` 实例：

```js
import { AbilityBuilder, createMongoAbility } from '@casl/ability'

export default function defineAbilityFor(user) {
  const { can, cannot, rules } = new AbilityBuilder(createMongoAbility);

  // defined permissions

  return createMongoAbility(rules);
}
```

### 何时使用 AbilityBuilder

* 在具有静态权限的应用程序中（即，权限不由管理员用户更改，而是在系统内部定义）
* 在任何使用自定义能力工厂函数的地方

> 请参见[自定义能力](../../advanced/customize-ability)以了解更多关于 `PureAbility` 类的信息。

## JSON 对象

在应用程序中定义规则不需要使用 `AbilityBuilder`，特别是如果您的规则是动态的（即存储在数据库中或由管理员用户管理）。在这种情况下，首选方式是使用 `JSON` 对象。您可以直接将 `JSON` 规则数组传递到 `Ability` 构造函数中。这样的规则称为原始规则

> 您可以在 [TypeScript 支持](/advanced/01.typescript) 中阅读更多关于 TypeScript 类型及其形状的信息

### JSON 对象示例

使用 `JSON` 的相同示例：

```js
import { createMongoAbility } from '@casl/ability';

export default createMongoAbility([
  {
    action: 'read',
    subject: 'Post'
  },
  {
    inverted: true,
    action: 'delete',
    subject: 'Post',
    conditions: { published: true }
  }
])
```

注意 `inverted` 字段，它表示规则是反向的（即禁止某些东西）。

### 原始规则的形状

[TypeScript](http://www.typescriptlang.org/) 中原始规则形状的简化版本（不含泛型）如下所示：

```ts
interface RawRule {
  action: string | string[]
  subject?: string | string[]
  /** an array of fields to which user has (or not) access */
  fields?: string[]
  /** an object of conditions which restricts the rule scope */
  conditions?: any
  /** indicates whether rule allows or forbids something */
  inverted?: boolean
  /** message which explains why rule is forbidden */
  reason?: string
}
```

如果您不熟悉 TypeScript，请不要担心，您仍有时间学习它 ;) 开玩笑，还是不开玩笑？

在上面的示例中，字段名后的 `?` 表示可选字段，因此除了 `action` 之外，所有内容都是可选的。`string[]` 表示字符串数组，`string | string[]` 表示常规 `string` 或字符串数组。现在您几乎了解了 TypeScript 的所有内容，不用谢 :)

### 何时使用 JSON 对象

* 在具有动态权限的应用程序中（即权限由管理员用户更改）
* 在通过网络层接收权限的应用程序中（例如单页应用程序或微服务）
* 为了使应用程序的包大小更小（如果您不使用 `AbilityBuilder` 或 `defineAbility`，它们可以被 [rollup] 或 [webpack] 等打包器摇树优化掉）

[rollup]: https://rollupjs.org/guide/en/
[webpack]: https://webpack.js.org/

现在，由于我们知道了定义规则的所有可能方式，让我们更深入地了解 `can` 和 `cannot` 方法。

## Rules

You can define as much rules as you need, CASL builds an index under the hood to keep checking logic fast. So, don't worry about performance.

You can define the same pair of action and subject with different conditions multiple times. For example:

```js
import { defineAbility } from '@casl/ability';

export default defineAbility((can) => {
  can('read', 'Article', { published: true });
  can('read', 'Article', { published: false, status: 'review' });
});
```

In such case, the pair of action/subject rules are combined by logical `OR`. More formally this can be translated as "users can read Article if it's published OR users can read Article if it's not published AND in review status".

But be careful, because `OR` logic returns `true` if one of its expressions are `true`, so the next code will always return `true`, even for articles that were not published:

```js
import { defineAbility } from '@casl/ability';

export default defineAbility((can) => {
  can('read', 'Article');
  can('read', 'Article', { published: true }); // (2)
});
```

More formally this code can be read as "can read any article OR can read published articles". As you see, the first statement always valid, so the `(2)` `can` with conditions has no effect.

It's also possible to restrict scope of direct rule with the inverted one for the same pair of action and subject. In such case, inverted rules are combined with direct ones by logical `AND`.

Let's change the example above to disallow reading unpublished articles:

```js
import { defineAbility } from '@casl/ability';

export default defineAbility((can, cannot) => {
  can('read', 'Article'); // direct rule
  cannot('read', 'Article', { published: false }); // inverted rule
});
```

This is read as "can read any article AND cannot read unpublished articles".

### Inverted rules order

It is important that in the example above `cannot read article unpublished` line comes after the `can read article` line. If they were reversed, `cannot read article unpublished` would be overridden by `can read article`.

> The rule of thumb is to define general rules first and more specific after general ones.

It was done so in order to be able to override inverted rules by regular ones.

### Best practice

Direct logic is easier to reason about for human mind, so use direct rules as much as possible! Moreover, this allows to keep permissions clean, more readable and reduces the risk of giving wrong permissions to the wrong users.

> You can remember this rule as: **Give permissions, don't take them away**

So, are there a valid usecases for inverted rules? **Yes**! They work very well when are not combined with regular rules and defined explicitly to express why particular action on particular subject was forbidden, for example:

```js
import { AbilityBuilder, createMongoAbility } from '@casl/ability';

async function defineAbility(user) {
  const hasPaidSubscription = await user.hasPaidSubscription();
  const { can, cannot, build } = new AbilityBuilder(createMongoAbility);

  if (hasPaidSubscription) {
    can('create', 'BlogPost');
  } else {
    cannot('create', 'BlogPost').because('You have not paid for monthly subscription');
  }

  return build()
}
```
