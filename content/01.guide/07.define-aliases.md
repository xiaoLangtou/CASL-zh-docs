---
title: 定义动作别名
categories: [guide]
order: 55
meta:
  keywords: ~
  description: ~
---

别名提供了将多个动作组合成一个的可能性。这也简化了当我们需要确保用户可以同时执行两个动作时的检查（例如，`delete` 和 `update`）。

要定义别名，我们需要使用 `createAliasResolver` 函数。它接受一个参数 - 别名到动作的映射。例如，这里我们将 modify 别名定义为 update 和 delete 动作的组合：

```js
import { defineAbility, createAliasResolver } from '@casl/ability'

const resolveAction = createAliasResolver({
  modify: ['update', 'delete']
});
const ability = defineAbility((can) => {
  can('modify', 'Post');
}, { resolveAction });

ability.can('modify', 'Post'); // true
ability.can('update', 'Post'); // true
ability.can('delete', 'Post'); // true
```

当你通过别名检查能力时，这意味着用户拥有所有必需的动作（或至少缺少一个），所以：

```js
ability.can('modify', 'Post') === ability.can('update', 'Post') && ability.can('delete', 'Post');
```

**请注意**别名只在一个方向上工作！这意味着 `modify` 是 `update` 和 `delete` 的别名，但 `update` 和 `delete` 不会自动形成 `modify` 别名。为了理解这意味着什么，让我们考虑相同的例子但使用不同的规则：

```ts
import { defineAbility, createAliasResolver } from '@casl/ability'

const resolveAction = createAliasResolver({
  modify: ['update', 'delete']
});
const ability = defineAbility((can) => {
  can(['update', 'delete'], 'Post');
}, { resolveAction });

ability.can('modify', 'Post'); // false <---
ability.can('update', 'Post'); // true
ability.can('delete', 'Post'); // true
```

我们对 `modify` 动作得到了 `false`，即使我们可以 `delete` 和 `update` 一个 Post！别名在 `PureAbility` 实例化级别或当你调用 `ability.update` 时解析一次。这样做是为了使 `ability.can` 更快。

你也可以在别名上定义别名，它们会递归解析：

```js
import { defineAbility, createAliasResolver } from '@casl/ability'

const resolveAction = createAliasResolver({
  modify: ['update', 'delete'],
  access: ['read', 'modify']
});
const ability = defineAbility((can) => {
  can('access', 'Post');
}, { resolveAction });

ability.can('access', 'Post'); // true
ability.can('modify', 'Post'); // true
ability.can('update', 'Post'); // true
ability.can('delete', 'Post'); // true
```

## 无效用法

在任何非生产环境中（由 `process.env.NODE_ENV` 确定），`createAliasResolver` 分析传入的对象并禁止：

1. 为 `manage` 动作创建别名。\
   `manage` 是保留的，表示任何动作，所以没有必要为它创建别名（例如，`createAliasResolver({ access: 'manage' })`）。
2. 创建指向自身的别名（例如，`createAliasResolver({ access: 'access' })`）。

它不会通过多个间接级别检测循环，所以你需要自己确保这一点。
