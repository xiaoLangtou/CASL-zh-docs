---
title: 介绍
categories: [guide]
order: 10
meta:
  keywords: ~
  description: ~
---

[![@casl/ability NPM version](https://badge.fury.io/js/%40casl%2Fability.svg)](https://badge.fury.io/js/%40casl%2Fability)
[![](https://img.shields.io/npm/dm/%40casl%2Fability.svg)](https://www.npmjs.com/package/%40casl%2Fability)
[![Support](https://img.shields.io/badge/Support-github%20discussions-green?style=flat&link=https://github.com/stalniy/casl/discussions)](https://github.com/stalniy/casl/discussions)

## 什么是 CASL？

CASL（发音为 /ˈkæsəl/，类似于 **castle**）是一个同构的 JavaScript 授权库，用于限制给定客户端可以访问的资源。它被设计为可增量采用，并且可以轻松地在简单的基于声明的授权和功能齐全的基于主体和属性的授权之间扩展。它使得在 UI 组件、API 服务和数据库查询之间管理和共享权限变得容易。

> CASL 实现了[基于属性的访问控制](https://en.wikipedia.org/wiki/Attribute-based_access_control)

## 快速开始

尝试 CASL.js 最简单的方法是使用 [Hello World 示例][example-hello-casl]。您可以在另一个标签页中打开它，并在我们进行一些基本示例时跟随操作。或者，您可以创建一个 Node.js 项目并将 `@casl/ability` 作为依赖项安装。

> [安装页面][guide-install] 提供了更多安装 CASL 的选项。

[example-hello-casl]: https://codesandbox.io/s/github/stalniy/casl-examples/tree/master/packages/hello-world
[guide-install]: /guide/install

## 基础概念

CASL 在能力级别上运行，即用户在应用程序中实际可以做什么。一个能力本身依赖于 4 个参数（后 3 个是可选的）：

1. **用户操作**\
   描述用户在应用程序中实际可以做什么。用户操作是一个词（通常是动词），取决于业务逻辑（例如，`prolong`、`read`）。通常它会是 CRUD 中的词汇列表 - `create`、`read`、`update` 和 `delete`。
2. **主体**\
   您想要检查用户操作的主体或主体类型。通常这是一个业务（或领域）实体（例如，`Subscription`、`Article`、`User`）。主体和主体类型之间的关系与对象实例和其类之间的关系相同。
3. **字段**\
   可用于将用户操作限制为仅匹配主体的字段（例如，允许版主更新 `Article` 的 `status` 字段，但不允许更新 `description` 或 `title`）
4. **条件**\
   将用户操作限制为仅匹配主体的条件。当您需要对特定主体给予权限时，这很有用（例如，允许用户管理自己的 `Article`）

CASL 的核心是一个系统，使我们能够使用清晰的 JavaScript 语法声明性地定义和检查用户权限：

```js @{data-filename="defineAbility.js"}
import { defineAbility } from '@casl/ability';

export default defineAbility((can, cannot) => {
  can('manage', 'all');
  cannot('delete', 'User');
});
```

> CASL 对 TypeScript 有完善的支持，但在本指南中我们将使用 JavaScript 以便于理解。详情请参见 [CASL TypeScript](/advanced/01.typescript)

在上面的示例中，我们刚刚定义了一个 `MongoAbility` 实例，它允许在应用程序中执行任何操作，除了删除用户。正如您可能猜到的，`can` 和 `cannot` 接受相同的参数但具有不同的含义：`can` 允许对指定主体执行操作，`cannot` 禁止它。两者最多可以接受 4 个参数（与[概念部分](#基础概念)中列出的顺序完全相同）。在这种情况下，`manage` 和 `delete` 是用户操作，`all` 和 `User` 是主体。

> `manage` 和 `all` 是 CASL 中的特殊关键字。`manage` 表示任何操作，`all` 表示任何主体。

现在让我们尝试检查权限

```js @{data-filename="app.js"}
import ability from './defineAbility.js';

ability.can('read', 'Post') // true
ability.can('read', 'User') // true
ability.can('update', 'User') // true
ability.can('delete', 'User') // false
ability.cannot('delete', 'User') // true
```

在上面的示例中，`MongoAbility` 实例允许我们以相当可读的方式检查权限。顺便说一下，所有这些示例都演示了基于主体类型（即对象类型或类）检查权限，但当您需要基于对象的属性（即属性）限制对象时，CASL 真正发挥作用。

## 条件

中型应用程序最常见的要求是能够限制用户，使他们只能对自己的资源执行操作。CASL 允许我们通过在定义步骤中将条件对象作为第 3 个参数传递给 `can` 和 `cannot` 方法来实现这一点。

在深入细节之前，让我们首先考虑博客网站权限的要求。在这样的博客中，用户

* 可以 `read` 任何 `Article`
* 可以 `update` 自己的 `Article`
* 可以为任何文章 `create` `Comment`
* 可以 `update` 自己的 `Comment`

让我们将其转换为 CASL：

```js @{data-filename="defineAbility.js"}
import { defineAbility } from '@casl/ability';

export default (user) => defineAbility((can) => {
  can('read', 'Article');

  if (user.isLoggedIn) {
    can('update', 'Article', { authorId: user.id });
    can('create', 'Comment');
    can('update', 'Comment', { authorId: user.id });
  }
});
```

Do you see how real business requirements are easily translated to code? Now let's check them!

```js
import defineAbilityFor from './defineAbility';

const user = { id: 1 };
const ability = defineAbilityFor(user);
const article = /* intentionally not defined */;

ability.can('read', article);
```

如您所见，您可以像检查主体类型一样检查主体！但是 `article` 变量内部包含什么？CASL 如何知道此变量引用的对象的主体类型？

您还记得主体及其类型彼此属于，就像对象实例及其类一样吗？CASL 也记住了这一点，并检索 `article.constructor.name` 作为其主体类型。

> 类在后端是自然的，但在前端开发中并不总是有意义。CASL 支持其他检测主体类型的方法，详情请参见[主体类型检测](../guide/subject-type-detection  )。

让我们回到我们的示例并为 `Article` 和 `Comment` 实体定义类：

```js @{data-filename="entities.js"}
class Entity {
  constructor(attrs) {
    Object.assign(this, attrs);
  }
}

export class Article extends Entity {}
```

这就是缺少 `article` 变量的示例最终的样子：

```js
import defineAbilityFor from './defineAbility';
import { Article } from './entities';

const user = { id: 1 };
const ability = defineAbilityFor(user);
const article = new Article();

ability.can('read', article); // user can read any article
```

再举几个例子来熟悉一下：

```js @{data-filename="app.js"}
import defineAbilityFor from './defineAbility';
import { Article } from './entities';

const user = { id: 1, isLoggedIn: true };
const ownArticle = new Article({ authorId: user.id });
const anotherArticle = new Article({ authorId: 2 });
const ability = defineAbilityFor(user);

ability.can('read', 'Article') // true
ability.can('update', 'Article') // true
ability.can('update', ownArticle) // true
ability.can('update', anotherArticle) // false, we can't update articles which were not written by us
```

> 尽管 `defineAbility` 回调中的 `can` 和 `cannot` 函数与 `MongoAbility` 类的 `can` 和 `cannot` 方法相似，但它们具有完全不同的目的并接受不同的参数。如果这让您感到困惑，请参见[使 `can` API 不那么令人困惑](../../cookbook/less-confusing-can-api)。

**请注意**，条件对象包含与我们要检查的实体相同的键。这就是 CASL 通过条件匹配实体的方式。在我们的例子中，它只是检查 `Article` 实例中的 `authorId` 是否等于条件对象中的 `authorId`。条件可能有多个字段，在这种情况下，所有字段都应该匹配（`AND` 逻辑）。

但条件不仅限于简单的相等检查！感谢 [ucast](https://github.com/stalniy/ucast)，`MongoAbility` 实例可以使用 [MongoDB 查询语言](http://docs.mongodb.org/manual/reference/operator/query/) 匹配对象。

> 如果您不熟悉 MongoDB 查询语言，请参见 [CASL 条件深入](../guide/conditions-in-depth) 了解详情

您可以多次定义具有不同条件的相同操作和主体对。例如，让我们允许我们的博客用户分享草稿和发布文章：

```js
import { defineAbility } from '@casl/ability';

export default function defineAbilityFor(user) {
  return defineAbility((can) => {
    can('read', 'Article', { published: true });
    can('read', 'Article', { published: false, sharedWith: user.id });
  });
}
```

在这种情况下，操作/主体规则对通过逻辑 `OR` 组合。更正式地说，这可以翻译为"如果文章已发布，用户可以读取文章，或者如果文章未发布且与他们共享，用户可以读取文章"。

但这还不是全部，如果您需要更细粒度的权限检查，您可以在主体的属性（即字段）上定义它们！

## 字段

有时您可能需要限制用户可以访问哪些字段。例如，让我们只允许版主发布 `Article`：

```js @{data-filename="defineAbility.js"}
import { defineAbility } from '@casl/ability';

export default (user) => defineAbility((can) => {
  can('read', 'Article');
  can('update', 'Article', ['title', 'description'], { authorId: user.id })

  if (user.isModerator) {
    can('update', 'Article', ['published'])
  }
});
```

在这里我们定义了任何用户都可以更新自己 `Article` 的 `title` 和 `description` 字段，只有版主可以更新 `published` 字段。

> 如果未指定字段，则允许用户访问任何字段。

要检查权限，请使用 `MongoAbility` 实例的相同 `can` 和 `cannot` 方法：

```js
import defineAbilityFor from './defineAbility';
import { Article } from './entities';

const moderator = { id: 2, isModerator: true };
const ownArticle = new Article({ authorId: moderator.id });
const foreignArticle = new Article({ authorId: 10 });
const ability = defineAbilityFor(moderator);

ability.can('read', 'Article') // true
ability.can('update', 'Article', 'published') // true
ability.can('update', ownArticle, 'published') // true
ability.can('update', foreignArticle, 'title') // false
```

> 对于更复杂的情况，您可以使用嵌套字段和通配符，详情请参见[限制字段访问](../guide/restricting-fields)

## 检查逻辑

让我们考虑一个用户可以发布文章的简单示例：

```js
import { defineAbility } from '@casl/ability';
import { Article } from './entities';

const ability = defineAbility((can) => {
  can('read', 'Article', { published: true })
});
const article = new Article({ published: true });

ability.can('read', article); // (1)
ability.can('do', 'SomethingUndeclared'); // (2)
ability.can('read', 'Article'); // (3)
```

第 `(1)` 行按预期返回 `true`。第 `(2)` 行返回 `false`，因为对于任何未知的主体或操作，CASL 返回 `false`，默认情况下一切都被禁止（如果不使用 `manage` 和 `all` 关键字）。但是您期望第 `(3)` 行返回什么？对于你们中的一些人来说，答案可能是意外的，它也返回 `true`。**为什么？！**

让我们回到我们的经验一段时间。从历史上看，大多数权限管理库都建立在角色或标志之上。因此，用户要么有权限，要么没有。这可以用伪代码表示：

```js
allow('read_article');
allow('update_article');
```

这被解释为"用户可以读取所有文章，用户可以更新所有文章"。所以，这是"全有或全无"的思维方式。

**但 CASL 不同！** 它允许我们向我们的权限提出不同的问题。所以，当您检查

* 主体时，您问"我可以读取这篇文章吗？"
* 主体类型时，您问"我可以读取某篇文章吗？"（即至少一篇文章）

当您没有要检查的实例但知道其类型时（例如，在创建期间），这非常有用，因此这允许您的应用程序快速失败。

> 如果您对主体类型进行检查，您需要在最终主体上再次检查权限，就在向 API 或数据库发送请求之前。

## 反向规则

本指南大量讨论了可允许的权限，但没有讨论不可允许的权限。这是有原因的。直接逻辑更容易理解，我们建议尽可能使用它。

要定义反向规则，您需要在 `defineAbility` 的回调中使用第 2 个参数。让我们给用户一个权限来做任何事情，但不能删除：

```js
import { defineAbility } from '@casl/ability';

const ability = defineAbility((can, cannot) => {
  can('manage', 'all');
  cannot('delete', 'all');
});

ability.can('read', 'Post'); // true
ability.can('delete', 'Post'); // false
```

如您所知，直接规则通过逻辑 `OR` 检查，另一方面，反向规则通过逻辑 `AND` 检查。所以，在上面的示例中，用户：

* 可以对所有实体做任何事情
* 并且不能删除任何实体

当为相同的操作和主体对定义直接和反向规则时，规则的顺序很重要：`cannot` 声明应该在 `can` 之后，否则它们将被 `can` 覆盖。例如，让我们禁止读取所有私有对象（那些具有属性 `private = true` 的对象）：

```js
const user = { id: 1 };
const ability = defineAbility((can, cannot) => {
  cannot('read', 'all', { private: true });
  can('read', 'all', { authorId: user.id });
});

ability.can('read', { private: true }); // false
ability.can('read', { authorId: user.id }); // true
ability.can('read', { authorId: user.id, private: true }); // true!
```

在这里我们得到了一个意外的结果，因为直接规则是最后一个。要修复结果，只需反转这些规则，**并且始终记住将反向规则放在直接规则之后！**

### 禁止原因

反向规则的好处是它们有助于明确禁止特定操作。此外，它们允许添加解释。让我们看看如何

```js @{data-filename="defineAbility.js"}
import { defineAbility } from '@casl/ability';

export default defineAbility((can, cannot) => {
  can('read', 'all');
  cannot('read', 'all', { private: true })
    .because('You are not allowed to read private information');
});
```

我们可以通过使用 `ForbiddenError` 检查权限来获取此消息：

```js
import { ForbiddenError } from '@casl/ability';
import ability from './defineAbility';

try {
  ForbiddenError.from(ability).throwUnlessCan('read', { private: true })
} catch (error) {
  if (error instanceof ForbiddenError) {
    console.log(error.message); // You are not allowed to read private information
  }

  throw error
}
```

> 要了解更多关于 `ForbiddenError` 的信息，请参见 [ForbiddenError API](/api/casl-ability#forbidden-error)

## 更新规则

有时，特别是在前端应用程序开发中，我们需要更新 `Ability` 实例（例如，在登录或注销时）。为此，我们可以使用 `update` 方法：

```js
import ability from './defineAbility';

ability.update([]); // forbids everything
ability.update([ // switch to readonly mode
  { action: 'read', subject: 'all' }
]);
```

我们也可以使用 `AbilityBuilder` 来创建规则：

```js
import { createMongoAbility, AbilityBuilder } from '@casl/ability';

const ability = createMongoAbility();

const { can, rules } = new AbilityBuilder(createMongoAbility);
can('read', 'all');

ability.update(rules);
```

要跟踪规则何时更新，我们可以订阅 `PureAbility` 实例的 `update`（在能力更新之前）或 `updated`（在能力更新之后）事件：

```js
const unsubscribe = ability.on('update', ({ rules, target }) => {
  // `rules` is an array passed to `update` method
  // `target` is a PureAbility instance that triggered event
})

unsubscribe() // removes subscription
```

## 还有什么？

CASL 没有"角色"的概念，这使它非常强大！由于 CASL 允许描述应用程序中的用户能力，您可以使用它来：

1. 实现[功能开关](https://en.wikipedia.org/wiki/Feature_toggle)\
   隐藏未完成的功能或仅向 beta 测试人员显示。
2. 进行 [A/B 测试](https://en.wikipedia.org/wiki/A/B_testing)\
   基于年龄、地区、国家或任何其他因素为某些用户隐藏功能，为其他用户显示
3. 简单的业务逻辑\
   如果用户的订阅已过期，则禁止用户观看视频

> 详情请参见[具有预定义权限的角色](/cookbook/roles-with-static-permissions)。

## 准备好了解更多？

我们已经简要介绍了 CASL.js 核心的所有功能 - 本指南的其余部分将以更精细的细节涵盖它们和其他高级功能，所以请确保通读所有内容！
