---
title: 限制字段访问
categories: [guide]
order: 40
meta:
  keywords: ~
  description: ~
---

有时你可能需要限制用户可以访问哪些字段。例如，让我们只允许版主发布 `Article`：

```js @{data-filename="defineAbility.js"}
import { AbilityBuilder, createMongoAbility } from '@casl/ability';

export default function defineAbilityFor(user) {
  const { can, rules } = new AbilityBuilder(createMongoAbility);

  can('read', 'Article');
  can('update', 'Article', ['title', 'description'], { authorId: user.id });

  if (user.isModerator) {
    can('update', 'Article', ['published']);
  }

  return createMongoAbility(rules);
}
```

现在我们可以检查字段的权限：

```js
import defineAbilityFor from './defineAbility';

const user = { id: 1 };
const moderator = { id: 2, isModerator: true };

defineAbilityFor(user).can('update', 'Article', 'published'); // false
defineAbilityFor(moderator).can('update', 'Article', 'published'); // true
```

**当你为带有条件的字段定义规则时要注意**，检查的结果会根据你传递的是主体还是主体类型而有所不同！为了说明差异，让我们定义一个简单的类：

```js @{data-filename="entities.js"}
export class Article {
  constructor(title, description, authorId) {
    this.title = title;
    this.description = description;
    this.authorId = authorId;
    this.published = false;
  }
}
```

让我们检查权限：

```js @{data-filename="app.js"}
import defineAbilityFor from './defineAbility';
import { Article } from './entities';

const user = { id: 1 };
const ownArticle = new Article('CASL in Action', '', user.id);
const anotherArticle = new Article('CASL in Vue apps', '', 2);
const ability = defineAbilityFor(user);

ability.can('update', ownArticle, 'title'); // true
ability.can('update', anotherArticle, 'title'); // false
ability.can('update', 'Article', 'title'); // true!
```

所以，最后一个检查返回了 `true`，乍一看似乎是错误的！但实际上不是。类似于没有字段的 [检查逻辑](/guide/intro#checking-logic)，我们问的是不同的问题：

* 当我们检查特定的 `Article` 实例时，我们问的是**用户能否更新这篇文章的标题**
* 当我们检查主体类型时，我们问的是**用户能否更新至少一篇文章的标题？**

检查权限的另一种方法是使用 `@casl/ability/extra` 子模块中的 `permittedFieldsOf` 辅助函数从 `PureAbility` 实例中提取所有允许的字段。相同的检查逻辑在这里适用：

```js
import { permittedFieldsOf } from '@casl/ability/extra';

// the same code from app.js, the example above

const ARTICLE_FIELDS = ['title', 'description', 'authorId', 'published'];
const options = { fieldsFrom: rule => rule.fields || ARTICLE_FIELDS };

let fields = permittedFieldsOf(ability, 'update', ownArticle, options); // ['title', 'description']
fields = permittedFieldsOf(ability, 'update', anotherArticle, options); // []
fields = permittedFieldsOf(ability, 'update', 'Article', options); // ['title', 'description'] !

if (fields.includes('published')) {
  // do something if can update published field
}
```

CASL 对我们实体的形状一无所知，所以告诉它的唯一方法是提供一个 `fieldsFrom` 函数。这个函数应该从规则中返回字段列表。如果允许（或不允许）管理所有字段，则规则没有字段。在这种情况下，我们返回所有字段，否则返回规则内的内容。

这个方法与 [lodash.pick] 结合使用非常有用，可以从用户请求中提取允许的字段

> 如果你需要支持通配符的 `pick`，请查看 [这个实现][pick.wildcards]

[lodash.pick]: https://lodash.com/docs/4.17.15#pick
[pick.wildcards]: https://gist.github.com/stalniy/855f3de3115c8a89824370cb4d8bb5a7

```js
import pick from 'lodash/pick';
import { permittedFieldsOf } from '@casl/ability/extra';

// the same code from app.js

const reqBody = {
  title: 'CASL',
  description: 'powerful',
  published: true, // only moderators are allowed to change this field!
};
const fields = permittedFieldsOf(ability, 'update', ownArticle, options);
const rawArticle = pick(reqBody, fields); // { title: 'CASL', description: 'powerful' }
```

多亏了这一点，试图发送属性的用户将无法克服权限限制。

> 要了解更多关于 `@casl/ability/extra` 的信息，请查看其 [API 文档](/api/casl-ability-extra#extra-submodule)

## 嵌套字段

CASL 允许你在嵌套字段上定义权限，只需使用点表示法，例如：

```js
import { defineAbility } from '@casl/ability';

export default defineAbility((can) => {
  can('read', 'User', ['address.city', 'address.street']);
});
```

## 字段模式

也可以使用模式为字段定义权限。你可以使用 `*` 匹配除点（即 `.`）之外的任何符号，使用 `**` 匹配任何符号。例如，你想要允许访问嵌套字段的所有字段（无论嵌套级别如何）：

```js
import { defineAbility } from '@casl/ability';

const ability = defineAbility((can) => {
  can('read', 'User', ['address.**']);
});

ability.can('read', 'User', 'address'); // true
ability.can('read', 'User', 'address.street'); // true
ability.can('read', 'User', 'address.city.name'); // true
```

或者你可以只允许访问嵌套字段的第一级：

```js
import { defineAbility } from '@casl/ability';

const ability = defineAbility((can) => {
  can('read', 'User', ['address.*']);
});

ability.can('read', 'User', 'address'); // true
ability.can('read', 'User', 'address.street'); // true
ability.can('read', 'User', 'address.city.name'); // false
```

或者你可以使用模式访问顶级字段。假设 `User` 实例有多个街道字段，如 `street1`、`street2` 等：

```js
import { defineAbility } from '@casl/ability';

const ability = defineAbility((can) => {
  can('read', 'User', ['street*']);
});

ability.can('read', 'User', 'street'); // true
ability.can('read', 'User', 'street1'); // true
ability.can('read', 'User', 'street2'); // true
```

### 字段模式表格

| 模式            | 示例         | 结果      |
| --------------- | -------------| --------- |
| address.*       |
|                 | `ability.can('read', 'User', 'address')`           | `true`  |
|                 | `ability.can('read', 'User', 'address.city')`      | `true`  |
|                 | `ability.can('read', 'User', 'address.city.name')` | `false` |
| address.**      |
|                 | `ability.can('read', 'User', 'address')`           | `true` |
|                 | `ability.can('read', 'User', 'address.city')`      | `true` |
|                 | `ability.can('read', 'User', 'address.city.name')` | `true` |
|                 | `ability.can('read', 'User', 'address.city.location.lat')` | `true` |
| address.*.name  |
|                 | `ability.can('read', 'User', 'address.*.name')`    | `true` |
|                 | `ability.can('read', 'User', 'address.city.name')` | `true` |
|                 | `ability.can('read', 'User', 'address.city.location.name')` | `false` |
| address.**.name |
|                 | `ability.can('read', 'User', 'address.*.name')`    | `true` |
|                 | `ability.can('read', 'User', 'address.city.name')` | `true` |
|                 | `ability.can('read', 'User', 'address.city.location.name')` | `true` |
| *.name          |
|                 | `ability.can('read', 'User', '*.name')`            | `true` |
|                 | `ability.can('read', 'User', 'city.name')`         | `true` |
|                 | `ability.can('read', 'User', 'address.city.name')` | `false` |
|                 | `ability.can('read', 'User', 'address.city.location.name')` | `false` |
| **.name         |
|                 | `ability.can('read', 'User', '*.name')`            | `true` |
|                 | `ability.can('read', 'User', 'city.name')`         | `true` |
|                 | `ability.can('read', 'User', 'address.city.name')` | `true` |
|                 | `ability.can('read', 'User', 'address.city.location.name')` | `true` |
|                 | `ability.can('read', 'User', 'address.city.code')` | `false` |
